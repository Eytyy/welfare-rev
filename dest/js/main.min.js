'use strict';

/* exported CORE */
var CORE = function () {
  // Cache Modules
  var modules = {};

  return {
    // REGISTER MODULE
    register: function register(moduleID, creator) {
      modules[moduleID] = {
        create: creator,
        instance: null
      };
    },

    registerEvent: function registerEvent(events, module) {
      if (this.is_obj(events) && module) {
        if (modules[module]) {
          modules[module].events = events;
        } else {
          console.log('there is an issue');
        }
      } else {
        console.log('there is an issue 2');
      }
    },
    triggerEvent: function triggerEvent(event) {
      var module = void 0;
      Object.keys(modules).forEach(function (key) {
        if (modules.hasOwnProperty(key)) {
          module = modules[key];
          if (module.events && module.events[event.type]) {
            module.events[event.type](event.data);
          }
        }
      });
    },


    // Start Module
    start: function start(moduleID) {
      var mod = modules[moduleID];
      if (mod) {
        mod.instance = mod.create(SHELL.create(this, moduleID));
        mod.instance.init();
      }
    },


    // START ALL MODULES
    startAll: function startAll() {
      var _this = this;

      Object.keys(modules).forEach(function (moduleID) {
        if (modules.hasOwnProperty(moduleID)) {
          _this.start(moduleID);
        }
      });
    },


    AJAX: {
      get: function get(url) {
        console.log('https://elasticbeanstalk-us-west-2-759804563210.s3.amazonaws.com/welfare-rev/' + url);
        var prom = new Promise(function (resolve, reject) {
          var req = new XMLHttpRequest();
          req.open('GET', 'https://elasticbeanstalk-us-west-2-759804563210.s3.amazonaws.com/welfare-rev/' + url);
          req.onload = function () {
            // This is called even on 404 etc so check the status
            if (req.status === 200) {
              // Resolve the promise with the response text
              resolve(req.response);
            } else {
              // Otherwise reject with the status text
              // which will hopefully be a meaningful error
              reject(Error(req.statusText));
            }
          };
          // Handle network errors
          req.onerror = function () {
            reject(Error('Network Error'));
          };

          // Make the request
          req.send(null);
        });
        return prom.then(function (response) {
          var data = JSON.parse(response);
          return data;
        }).catch(function (err) {
          console.log(err);
        });
      }
    },

    // DOM METHODS
    DOM: {
      query: function query(selector) {
        return document.querySelector(selector);
      },
      queryAll: function queryAll(selector) {
        return document.querySelectorAll(selector);
      },
      appendTemplate: function appendTemplate(template, target) {
        target.insertAdjacentHTML('beforeend', template);
      },
      createElement: function createElement(el, opts) {
        var DOMel = document.createElement(el);
        if (opts.class) {
          opts.class.forEach(function (classi) {
            DOMel.classList.add(classi);
          });
        }
        return DOMel;
      }
    },

    getUrlHash: function getUrlHash() {
      var url = window.location.hash.substr(1) || '/';
      return url;
    },
    is_arr: function is_arr(arr) {
      return Array.isArray(arr);
    },
    is_obj: function is_obj(obj) {
      return Object.prototype.toString.call(obj) === '[object Object]';
    }
  };
}();
'use strict';

var MAIN = {
  init: function init() {
    // Register Modules
    CORE.register('overlay', OVERLAY);
    CORE.register('messages', MESSAGES);
    CORE.register('info', INFO);
    CORE.register('about', ABOUT);
    CORE.register('nav', NAV);
    CORE.register('map', MAP);
    CORE.register('welfare', WELFARE);
    CORE.startAll();

    // Listen to state events
    window.onpopstate = function () {
      var activeLayer = CORE.getUrlHash();
      // Notify core of state event
      CORE.triggerEvent({
        type: 'session-state-pop',
        data: activeLayer
      });
    };
  }
};

window.onload = function () {
  MAIN.init();
};
"use strict";

var mapStyles = [{ "featureType": "all", "elementType": "labels", "stylers": [{ "visibility": "off" }] }, { "featureType": "all", "elementType": "labels.text.fill", "stylers": [{ "saturation": 36 }, { "color": "#000000" }, { "lightness": 40 }] }, { "featureType": "all", "elementType": "labels.text.stroke", "stylers": [{ "visibility": "on" }, { "color": "#000000" }, { "lightness": 16 }] }, { "featureType": "all", "elementType": "labels.icon", "stylers": [{ "visibility": "off" }] }, { "featureType": "administrative", "elementType": "geometry.fill", "stylers": [{ "color": "#000000" }, { "lightness": 20 }] }, { "featureType": "administrative", "elementType": "geometry.stroke", "stylers": [{ "color": "#000000" }, { "lightness": 17 }, { "weight": 1.2 }] }, { "featureType": "administrative.locality", "elementType": "labels", "stylers": [{ "visibility": "off" }] }, { "featureType": "administrative.neighborhood", "elementType": "labels", "stylers": [{ "visibility": "off" }] }, { "featureType": "administrative.land_parcel", "elementType": "labels", "stylers": [{ "visibility": "off" }] }, { "featureType": "landscape", "elementType": "geometry", "stylers": [{ "color": "#262624" }, { "lightness": 20 }] }, { "featureType": "landscape", "elementType": "labels", "stylers": [{ "hue": "#ff0000" }] }, { "featureType": "landscape", "elementType": "labels.text", "stylers": [{ "visibility": "off" }] }, { "featureType": "landscape", "elementType": "labels.icon", "stylers": [{ "color": "#ff0000" }] }, { "featureType": "landscape.man_made", "elementType": "labels", "stylers": [{ "visibility": "off" }] }, { "featureType": "landscape.natural", "elementType": "labels", "stylers": [{ "visibility": "off" }] }, { "featureType": "landscape.natural.landcover", "elementType": "labels", "stylers": [{ "visibility": "off" }] }, { "featureType": "landscape.natural.terrain", "elementType": "labels", "stylers": [{ "visibility": "off" }] }, { "featureType": "poi", "elementType": "geometry", "stylers": [{ "color": "#000000" }, { "lightness": 21 }] }, { "featureType": "poi", "elementType": "labels", "stylers": [{ "visibility": "off" }] }, { "featureType": "poi.attraction", "elementType": "labels", "stylers": [{ "visibility": "off" }] }, { "featureType": "poi.business", "elementType": "labels", "stylers": [{ "visibility": "off" }] }, { "featureType": "poi.government", "elementType": "labels", "stylers": [{ "visibility": "off" }] }, { "featureType": "poi.medical", "elementType": "labels", "stylers": [{ "visibility": "off" }] }, { "featureType": "poi.park", "elementType": "labels", "stylers": [{ "visibility": "off" }] }, { "featureType": "poi.place_of_worship", "elementType": "labels", "stylers": [{ "visibility": "off" }] }, { "featureType": "poi.school", "elementType": "labels", "stylers": [{ "visibility": "off" }] }, { "featureType": "poi.sports_complex", "elementType": "labels", "stylers": [{ "visibility": "off" }] }, { "featureType": "road", "elementType": "labels", "stylers": [{ "visibility": "off" }] }, { "featureType": "road.highway", "elementType": "geometry.fill", "stylers": [{ "color": "#000000" }, { "lightness": 17 }] }, { "featureType": "road.highway", "elementType": "geometry.stroke", "stylers": [{ "color": "#000000" }, { "lightness": 29 }, { "weight": 0.2 }] }, { "featureType": "road.arterial", "elementType": "geometry", "stylers": [{ "color": "#000000" }, { "lightness": 18 }] }, { "featureType": "road.local", "elementType": "geometry", "stylers": [{ "color": "#000000" }, { "lightness": 16 }] }, { "featureType": "transit", "elementType": "geometry", "stylers": [{ "color": "#000000" }, { "lightness": 19 }] }, { "featureType": "water", "elementType": "geometry", "stylers": [{ "color": "#000000" }, { "lightness": 17 }] }];
"use strict";

/* Mediator */
var SHELL = {
  create: function create(core, moduleID) {
    return {
      await: function await() {},
      get: function get(url) {
        return core.AJAX.get(url);
      },
      post: function post() {},
      getHash: function getHash() {
        return core.getUrlHash();
      },
      notify: function notify(event) {
        if (core.is_obj(event) && event.type) {
          core.triggerEvent(event);
        }
      },
      listen: function listen(events) {
        if (core.is_obj(events)) {
          core.registerEvent(events, moduleID);
        }
      },
      createElement: function createElement(el, opts) {
        return core.DOM.createElement(el, opts);
      },
      find: function find(selector) {
        return core.DOM.query(selector);
      },
      findAll: function findAll(selector) {
        return core.DOM.queryAll(selector);
      },
      injectTemplateText: function injectTemplateText(template, target) {
        core.DOM.appendTemplate(template, target);
      }
    };
  }
};
'use strict';

var ABOUT = function ABOUT(shell) {
  var domMap = {};
  var aboutState = {
    active: false,
    currentAbout: null
  };
  var dataURL = 'data/about.json';
  var dataCache = '';

  return {
    init: function init() {
      domMap.$container = shell.find('#about');
      domMap.$title = shell.find('.about-title');
      domMap.$desc = shell.find('.about-desc');
      domMap.$toggleBtn = shell.find('.map-about__grabber');

      this.onAboutClicked = this.onAboutClicked.bind(this);

      domMap.$toggleBtn.addEventListener('click', this.closeAbout);

      shell.listen({
        'about-clicked': this.onAboutClicked
      });
    },


    // fetch about data
    fetchData: function fetchData() {
      return shell.get(dataURL).then(function (results) {
        return results;
      }).catch(function (err) {
        console.log(err);
        return '';
      });
    },
    closeAbout: function closeAbout() {
      aboutState.active = !aboutState.active;
      domMap.$container.classList.remove('js-active');
    },
    openAbout: function openAbout() {
      aboutState.active = !aboutState.active;
      domMap.$container.classList.add('js-active');
    },
    toggleAbout: function toggleAbout(target) {
      // if about section is active; visible
      // and the current about is the same as target the close
      // this means we clicked the same about twice and we are toggling
      if (aboutState.active && aboutState.currentAbout === target) {
        this.closeAbout();
      }
      // if about section is not active; hidden, show it
      else if (!aboutState.active) {
          this.openAbout();
        }
    },
    updateAbout: function updateAbout(target) {
      if (aboutState.currentAbout !== target) {
        var data = dataCache[target];
        domMap.$title.innerHTML = data.title;
        domMap.$desc.innerHTML = data.desc;
      }

      this.toggleAbout(target);
      aboutState.currentAbout = target;
    },
    onAboutClicked: function onAboutClicked(data) {
      var _this = this;

      // If data is available then update about from cache
      if (dataCache !== '') {
        this.updateAbout(data);
        return true;
      }
      // Else fetch data, update the cache, then call update
      this.fetchData().then(function (results) {
        dataCache = results;
        _this.updateAbout(data);
      }).catch(function (err) {
        console.log(err);
      });
      return true;
    }
  };
};
'use strict';

var INFO = function INFO(shell) {
  var debugmode = false;

  var domMap = {};

  var tplMap = {
    projects: 'map-info-projects.tpl.hbs',
    buildings: 'map-info-buildings.tpl.hbs',
    housing: 'map-info-housing.tpl.hbs'
  };

  var dataCache = {
    projects: {},
    buildings: {},
    housing: {}
  };

  return {
    init: function init() {
      // Cache dom elements
      domMap.$container = shell.find('#info');

      // Bind methods to this
      this.updateProject = this.updateProject.bind(this);
      this.hideInfoWindow = this.hideInfoWindow.bind(this);
      this.resetInfo = this.resetInfo.bind(this);

      // setup window
      this.setupInfoWindow();

      shell.find('.map-info__grabber').addEventListener('click', this.toggleInfoExpand);
      shell.find('.back2map-btn').addEventListener('click', this.onBack2mapClick);

      // Listen to global events
      shell.listen({
        'update-project': this.updateProject,
        'layer-updated': this.hideInfoWindow,
        'category-closed': this.hideInfoWindow,
        'reset-map': this.resetInfo
      });
    },
    onBack2mapClick: function onBack2mapClick() {
      shell.notify({
        type: 'back2map',
        data: ''
      });
    },
    showInfoWindow: function showInfoWindow() {
      domMap.$info.classList.add('js-view-mode');
    },
    hideInfoWindow: function hideInfoWindow(event) {
      if (!event.fromMap) {
        domMap.$info.classList.remove('js-view-mode');
      }
    },
    toggleInfoExpand: function toggleInfoExpand() {
      if (domMap.$info.classList.contains('js-infoExpanded')) {
        domMap.$info.classList.remove('js-infoExpanded');
      } else {
        domMap.$info.classList.add('js-infoExpanded');
      }
    },
    resetInfo: function resetInfo() {
      domMap.$info.classList.remove('js-infoExpanded');
    },
    updateInfoWindow: function updateInfoWindow(data) {
      shell.notify({
        type: 'app-updating',
        data: {
          message: 'Loading Project'
        }
      });

      var activeLayer = data.activeLayer;
      var activeProject = data.activeProject;
      var activeProjectName = activeLayer === 'housing' ? data.activeProjectName - 1 : data.activeProjectName;

      var projectData = void 0;
      var activeProjectID = void 0;

      if (activeLayer === 'projects') {
        projectData = activeProject.f;
        activeProjectID = projectData.OBJECTID;
      } else if (activeLayer === 'buildings') {
        projectData = activeProject.alldata;
        activeProjectID = projectData.ID;
      } else {
        projectData = activeProject;
        activeProjectID = projectData.getProperty('OBJECTID');
      }

      var module = this;
      domMap.$infoInner.scrollTop = 0;
      domMap.$info.classList.remove('js-infoExpanded');

      // Add Project info to html
      function appendInfo(infoData) {
        var tpl = tplMap[data.activeLayer];

        Handlebars.registerHelper({
          or: function or(v1, v2) {
            var rval = v1 || v2;
            return rval;
          },
          and: function and(v1, v2) {
            var rval = v1 && v2;
            return rval;
          },
          eq: function eq(v1, v2) {
            var rval = v1 === v2;
            return rval;
          },
          ne: function ne(v1, v2) {
            var rval = v1 !== v2;
            return rval;
          },
          formatCurr: function formatCurr(v) {
            var val = v ? v.toString().split('.') : '';
            val[0] = val[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            return val;
          },
          formatFileName: function formatFileName(v) {
            var val = v.match(/[^\\/]+$/)[0];
            return val;
          },
          notEmpty: function notEmpty(v) {
            var val = v ? !(v.length === 0) : false;
            return val;
          },
          ico: function ico(v) {
            if (v === 'True' || v === 'Yes') {
              return 'check';
            }
            return 'cross';
          }
        });

        var rendered = Handlebars.templates[tpl](infoData);
        domMap.$infoInner.innerHTML = rendered;

        shell.notify({
          type: 'app-updated',
          data: {
            message: ''
          }
        });
        if (debugmode) {
          console.log('loaded');
        }
      }

      if (dataCache[activeLayer][activeProjectID]) {
        shell.notify({
          type: 'app-updated',
          data: {
            message: ''
          }
        });
        if (activeLayer === 'housing') {
          appendInfo(Object.assign({}, dataCache[activeLayer][activeProjectID].alldata[activeProjectName], { images: dataCache[activeLayer][activeProjectID].images }, {
            building: dataCache[activeLayer][activeProjectID].buildingName,
            study: 'Unit No. ' + (activeProjectName + 1)
          }));
        } else {
          appendInfo(dataCache[activeLayer][activeProjectID]);
        }
        // Update Info
        this.showInfoWindow();
        return true;
      }

      function fetchImages(id) {
        var url = 'resources/images/' + activeLayer + '/' + id;
        return shell.get(url).then(function (images) {
          return images;
        }).catch(function (err) {
          console.log(err);
        });
      }

      function fetchExtraResources(id) {
        var url = 'resources/other/' + activeLayer + '/' + id;
        return shell.get(url).then(function (resources) {
          return resources;
        }).catch(function (err) {
          console.log(err);
        });
      }

      function fetchProjectResources() {
        var resourcesID = projectData.ukey;

        Promise.all([fetchImages(resourcesID), fetchExtraResources(resourcesID)]).then(function (allData) {
          var obj = {
            miscImages: [],
            otherFiles: []
          };
          allData[0].data.forEach(function (item, index) {
            if (/before.jpg/i.test(item)) {
              obj.beforeImage = item;
            } else if (/after.jpg/i.test(item)) {
              obj.afterImage = item;
            } else if (/main.jpg/i.test(item)) {
              obj.mainImage = item;
            } else if (index !== 0) {
              obj.miscImages.push(item);
            }
          });

          allData[1].data.forEach(function (item, index) {
            if (index !== 0) {
              obj.otherFiles.push(item);
            }
          });

          var completeData = Object.assign(projectData, obj);
          // Update Cache
          dataCache[activeLayer][activeProjectID] = completeData;
          // Update Info
          appendInfo(completeData);
        }).catch(function (error) {
          console.log(error);
          // Update Cache
          dataCache[activeLayer][activeProjectID] = data;
          // Update Info
          appendInfo(data);
        });
        module.showInfoWindow();
      }

      function fetchBuildingResources() {
        var resourcesID = projectData.ID;

        fetchImages(resourcesID).then(function (allData) {
          var imageData = data.activeProject.alldata.ImageData;
          var regex = /(\w*)(?:\.jpg)/i;

          var obj = {
            images: []
          };

          allData.data.forEach(function (image, index) {
            if (index !== 0) {
              var caption = imageData.find(function (el) {
                return el.PathNew === regex.exec(image)[1];
              }).name;
              if (caption) {
                obj.images.push({
                  image: image,
                  caption: caption
                });
              }
            }
          });
          Object.assign(projectData, obj);

          // Update Cache
          dataCache[activeLayer][activeProjectID] = projectData;

          // Update Info
          appendInfo(projectData);

          module.showInfoWindow();
        }).catch(function (error) {
          console.log(error);
          // Update Cache
          dataCache[activeLayer][activeProjectID] = data;
          // Update Info
          appendInfo(data);
          module.showInfoWindow();
        });
      }

      function fetchHousingResources() {
        if (debugmode) {
          console.log('fetch housing');
        }

        fetchImages(activeProjectID).then(function (allData) {
          var regex = /\w*(?:\.jpg)/i;
          var obj = {
            images: []
          };
          allData.data.forEach(function (image, index) {
            if (index !== 0 && regex.test(image)) {
              obj.images.push(image);
            }
          });
          var completeData = Object.assign(projectData, obj);
          dataCache[activeLayer][activeProjectID] = completeData;
          appendInfo(Object.assign({}, completeData.alldata[activeProjectName], { images: completeData.images }, {
            building: completeData.buildingName,
            study: 'Unit No. ' + (activeProjectName + 1)
          }));
        }).catch(function (err) {
          console.log(err);

          appendInfo(Object.assign({}, projectData.alldata[activeProjectName], {
            building: projectData.buildingName,
            study: 'Unit No. ' + (activeProjectName + 1)
          }));
        });

        module.showInfoWindow();
      }

      switch (activeLayer) {
        case 'projects':
          fetchProjectResources();
          break;
        case 'buildings':
          fetchBuildingResources();
          break;
        case 'housing':
          fetchHousingResources();
          break;
        default:
          break;
      }
    },
    setupInfoWindow: function setupInfoWindow() {
      var tplName = 'map-info.tpl.hbs';
      var tpl = Handlebars.templates[tplName]();

      shell.injectTemplateText(tpl, domMap.$container);

      domMap.$infoGrabber = shell.find('.map-info__grabber');
      domMap.$infoInner = shell.find('.map-info__inner');
      domMap.$info = shell.find('.map-info');
    },
    updateProject: function updateProject(event) {
      this.updateInfoWindow(event);
    }
  };
};
'use strict';

/* MAP MODULE */
var WELFARE = function WELFARE(shell) {
  var debugmode = false;

  // State map: object to be used as the single source for the app state
  var state = {
    activeLayer: null,
    previousLayer: null,
    previousProject: null,
    previousProjectName: '',
    activeProject: null,
    activeProjectName: '',
    activeProjectLatLang: null
  };

  /* Initializes the app state by setting the active layer,
   * and triggers a `init-layer-state` event.
   */
  var initState = function initState() {
    state.activeLayer = shell.getHash();
    // Notify
    shell.notify({
      type: 'init-layer-state',
      data: {
        previousLayer: state.previousLayer,
        activeLayer: state.activeLayer
      }
    });
  };

  var onBack2Map = function onBack2Map() {
    shell.notify({
      type: 'reset-map',
      data: {
        activeProject: state.activeProject,
        activeLayer: state.activeLayer
      }
    });
  };

  /* Changes the active layer, and triggers a `layer-update` event.
   */
  var updateLayerState = function updateLayerState(activeLayer) {
    state.previousLayer = state.activeLayer;
    state.activeLayer = activeLayer;
    if (debugmode) {
      var logMsg = '<layer-update> Prev: ' + state.previousLayer + ' | Active: ' + state.activeLayer;
      console.log(logMsg);
    }
    shell.notify({
      type: 'reset-project',
      data: {
        activeProject: state.activeProject,
        activeLayer: state.activeLayer
      }
    });
    // Notify
    shell.notify({
      type: 'layer-updated',
      data: {
        previousLayer: state.previousLayer,
        activeLayer: state.activeLayer
      }
    });
  };

  var updateProject = function updateProject() {
    shell.notify({
      type: 'update-project',
      data: {
        activeLayer: state.activeLayer,
        activeProject: state.activeProject,
        activeProjectName: state.activeProjectName,
        previousProject: state.previousProject,
        previousProjectName: state.previousProjectName,
        activeProjectLatLang: state.activeProjectLatLang
      }
    });
  };

  var onProjectNavClick = function onProjectNavClick(event) {
    var obj = void 0;
    var cat = void 0;
    switch (state.activeLayer) {
      case 'housing':
        obj = event.data[state.activeLayer][event.category];
        break;
      case 'buildings':
        cat = event.category.replace(/-/g, ' - ');
        obj = event.data[state.activeLayer].find(function (project) {
          return project.name === cat;
        }).alldata[event.target];
        break;
      default:
        obj = event.data[state.activeLayer][event.category][event.target];
        break;
    }
    if (debugmode) {
      console.log(obj);
    }

    var latLngs = obj.getGeometry().getAt(0).getAt(0);

    state.previousProject = state.activeProject;
    state.previousProjectName = state.activeProjectName;

    state.activeProject = obj;
    state.activeProjectLatLang = latLngs;
    state.activeProjectName = event.target;

    updateProject();
  };

  var onProjectMapClick = function onProjectMapClick(event) {
    state.previousProject = state.activeProject;
    state.previousProjectName = state.activeProjectName;

    state.activeProject = event.data.feature;
    state.activeProjectLatLang = event.data.latLng;

    switch (state.activeLayer) {
      case 'projects':
        state.activeProjectName = state.activeProject.getProperty('RelatedEnglishTitle');
        break;
      case 'buildings':
        state.activeProjectName = state.activeProject.alldata.BuildingName;
        break;
      case 'housing':
        state.activeProjectName = '1';
        break;
      default:
        break;
    }

    updateProject();
  };

  var onCategoryClosed = function onCategoryClosed() {
    if (state.activeProject) {
      shell.notify({
        type: 'reset-project',
        data: {
          activeProject: state.activeProject,
          activeLayer: state.activeLayer
        }
      });

      if (debugmode) {
        console.log('reset project and map');
      }
    }
  };

  return {
    init: function init() {
      initState();

      shell.listen({
        'session-state-pop': updateLayerState,
        'project-clicked': onProjectMapClick,
        'project-nav-clicked': onProjectNavClick,
        'category-closed': onCategoryClosed,
        back2map: onBack2Map
      });
    },
    destroy: function destroy() {}
  };
};
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* MAP MODULE */
var MAP = function MAP(shell) {
  var map = void 0;
  var domMap = {};
  var config = {
    layers: {},
    styles: {
      strokeWeight: 2,
      strokeColor: 'transparent',
      fillColor: '#e2cd57',
      fillOpacity: 1
    },
    options: {
      center: { lat: 31.777, lng: 35.234 },
      zoom: 16,
      styles: mapStyles
    }
  };

  return {
    init: function init() {
      var _this = this;

      // Cache map element
      domMap.map = shell.find('#map');

      // Create new instance of google maps
      map = new google.maps.Map(domMap.map, config.options);

      // Retrieve the layers and set them up
      console.log('https://elasticbeanstalk-us-west-2-759804563210.s3.amazonaws.com/welfare-rev/');
      shell.get('data/layers.json').then(function (data) {
        _this.setupLayers(data);
      });

      // Bind methods to this
      this.updateMap = this.updateMap.bind(this);
      this.updateProject = this.updateProject.bind(this);
      this.resetProject = this.resetProject.bind(this);

      // listen to events
      shell.listen({
        'init-layer-state': this.updateMap,
        'layer-updated': this.updateMap,
        'update-project': this.updateProject,
        'reset-project': this.resetProject,
        'reset-map': this.resetProject
      });
    },
    destroy: function destroy() {},


    /* Setup layers
     */
    setupLayers: function setupLayers(data) {
      Object.keys(data).forEach(function (key) {
        var obj = {};
        obj.dataLayer = new google.maps.Data();
        obj.dataLayer.setStyle(config.styles);
        obj.dataLoaded = false;
        obj.eventAdded = false;
        obj.visible = false;
        config.layers[key] = Object.assign({}, obj, data[key]);
      });

      shell.notify({
        type: 'map-is-loaded',
        data: map
      });

      shell.notify({
        type: 'app-updated',
        data: {
          message: 'yo'
        }
      });

      shell.notify({
        type: 'layers-created',
        data: config.layers
      });
    },
    disableLayer: function disableLayer(layer) {
      if (layer) {
        var affectedLayer = layer;
        affectedLayer.visible = false;
        affectedLayer.dataLayer.setMap(null);
      }
    },
    enableLayer: function enableLayer(layer) {
      var affectedLayer = layer;
      affectedLayer.visible = true;
      affectedLayer.dataLayer.setMap(map);
    },


    /* loadMap
     */
    loadMap: function loadMap(active, previous) {
      var _this2 = this;

      // Alias layers
      var ACTIVE_LAYER = active ? config.layers[active] : null;
      var PREVIOUS_LAYER = previous ? config.layers[previous] : null;

      /* If active is defined, and active equals previous and the active layer is visible:
       * It means we are triggering the same layer which is already visible.
       *
       * If active is the root '/' & previous is not:
       * It means we are navigating back to the root "initial state"
       *
       * In both cases: We hide the layers by unsetting the map and returning
       */
      if (active && active === previous || previous && previous !== '/' && (active === '/' || !active)) {
        if (ACTIVE_LAYER && ACTIVE_LAYER.visible) {
          this.disableLayer(ACTIVE_LAYER);
        } else if (!ACTIVE_LAYER) {
          this.disableLayer(PREVIOUS_LAYER);
        } else {
          this.enableLayer(ACTIVE_LAYER);
        }
        shell.notify({
          type: 'layers-data-updated',
          data: {
            active: ACTIVE_LAYER,
            previous: PREVIOUS_LAYER
          }
        });
        return true;
      }

      /* If active is empty or If active is the root '/' and previous is empty:
       * No layer is active; there is nothing to load. return;
       */
      if (!active || active === '/' && !previous) {
        return true;
      }

      /* If we are here it means we need to load a new layer:
       * 1. Fetch data, if it's not available.
       * 2. Unset the previous layer and set the map for the active layer.
      */
      // Fetch
      if (active && config.layers[active] && !config.layers[active].dataLoaded) {
        var _ret = function () {
          shell.notify({
            type: 'app-updating',
            data: {
              message: 'Loading ' + active + ' Layer'
            }
          });

          // Get the geodata to be placed on the map first
          var getGeoData = function getGeoData(url) {
            var prom = new Promise(function (resolve, reject) {
              try {
                ACTIVE_LAYER.dataLayer.loadGeoJson(url, {}, function (features) {
                  resolve(features);
                });
              } catch (err) {
                reject(err);
              }
            });
            return prom;
          };

          var updateLayersData = function updateLayersData(features) {
            ACTIVE_LAYER.data = features;
            ACTIVE_LAYER.dataLoaded = true;

            _this2.enableLayer(ACTIVE_LAYER);

            if (previous && previous !== '/' && previous !== active) {
              _this2.disableLayer(PREVIOUS_LAYER);
            }

            shell.notify({
              type: 'app-updated',
              data: {
                message: ''
              }
            });

            shell.notify({
              type: 'layers-data-updated',
              data: {
                active: ACTIVE_LAYER,
                previous: PREVIOUS_LAYER
              }
            });
          };

          if (active === 'projects') {
            var url = ACTIVE_LAYER.url;
            getGeoData(url).then(function (features) {
              updateLayersData(features);
            }).catch(function (err) {
              console.log(err);
            });
          } else {
            (function () {
              var geoUrl = ACTIVE_LAYER.keysUrl;
              var allUrl = ACTIVE_LAYER.url;
              var geoData = void 0;

              getGeoData(geoUrl).then(function (features) {
                geoData = features;
                return shell.get(allUrl).then(function (allData) {
                  return allData;
                }).catch(function (err) {
                  console.log(err);
                });
              }).catch(function (err) {
                console.log(err);
              }).then(function (allData) {
                var data = {};
                var counter = 1;
                if (active === 'buildings') {
                  var _iteratorNormalCompletion = true;
                  var _didIteratorError = false;
                  var _iteratorError = undefined;

                  try {
                    for (var _iterator = allData.MainTable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                      var el = _step.value;

                      var item = el[0].SERIAL_NO;
                      data[item] = el[0];
                    }
                  } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                      }
                    } finally {
                      if (_didIteratorError) {
                        throw _iteratorError;
                      }
                    }
                  }

                  var _iteratorNormalCompletion2 = true;
                  var _didIteratorError2 = false;
                  var _iteratorError2 = undefined;

                  try {
                    for (var _iterator2 = geoData[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                      var _el = _step2.value;

                      var serial = _el.getProperty('SERIAL_NO');
                      var obj = {};
                      if (data[serial]) {
                        obj.alldata = data[serial];
                        Object.assign(_el, obj);
                      }
                    }
                  } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                      }
                    } finally {
                      if (_didIteratorError2) {
                        throw _iteratorError2;
                      }
                    }
                  }
                } else {
                  var _iteratorNormalCompletion3 = true;
                  var _didIteratorError3 = false;
                  var _iteratorError3 = undefined;

                  try {
                    for (var _iterator3 = Object.keys(allData)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                      var _el2 = _step3.value;

                      var _item = allData[_el2][0].SERIAL_NO;
                      if (!data[_item]) {
                        data[_item] = [];
                      }
                      data[_item].push(allData[_el2][0]);
                    }
                  } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                      }
                    } finally {
                      if (_didIteratorError3) {
                        throw _iteratorError3;
                      }
                    }
                  }

                  var _iteratorNormalCompletion4 = true;
                  var _didIteratorError4 = false;
                  var _iteratorError4 = undefined;

                  try {
                    for (var _iterator4 = geoData[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                      var _el3 = _step4.value;

                      var _serial = _el3.getProperty('SERIAL_NO');
                      var _obj = {};
                      if (data[_serial]) {
                        _obj.alldata = data[_serial];
                        Object.assign(_el3, _obj, { buildingName: 'Building No. ' + counter });
                      }
                      counter += 1;
                    }
                  } catch (err) {
                    _didIteratorError4 = true;
                    _iteratorError4 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion4 && _iterator4.return) {
                        _iterator4.return();
                      }
                    } finally {
                      if (_didIteratorError4) {
                        throw _iteratorError4;
                      }
                    }
                  }
                }
                updateLayersData(geoData);
              }).catch(function (err) {
                console.log(err);
              });
            })();
          }

          if (!ACTIVE_LAYER.eventAdded) {
            ACTIVE_LAYER.dataLayer.addListener('click', function (event) {
              shell.notify({
                type: 'project-clicked',
                data: {
                  data: event,
                  active_layer: ACTIVE_LAYER
                }
              });
            });
            ACTIVE_LAYER.eventAdded = true;
          }

          return {
            v: true
          };
        }();

        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
      }
      // Unset previous
      if (previous && previous !== '/' && previous !== active) {
        this.disableLayer(PREVIOUS_LAYER);
      }
      // Set active
      this.enableLayer(ACTIVE_LAYER);

      shell.notify({
        type: 'layers-data-updated',
        data: {
          active: ACTIVE_LAYER,
          previous: PREVIOUS_LAYER
        }
      });

      return true;
    },


    /* Update map
     */
    updateMap: function updateMap(evt) {
      var _this3 = this;

      // check if layers setup is done first.
      if (Object.keys(config.layers).length > 0) {
        this.loadMap(evt.activeLayer, evt.previousLayer);
        return;
      }

      // wait for layers setup to be done before calling loadMap
      var check = void 0;

      var wait = setInterval(function () {
        check();
      }, 200);

      check = function check() {
        if (Object.keys(config.layers).length > 0) {
          _this3.loadMap(evt.activeLayer, evt.previousLayer);
          clearInterval(wait);
        }
      };
    },
    resetProject: function resetProject(event) {
      var activeProject = event.activeProject;
      var dataLayer = config.layers[event.activeLayer].dataLayer;

      dataLayer.overrideStyle(activeProject, config.styles);
      map.panTo({ lat: 31.777, lng: 35.234 });
      map.setZoom(16);
    },


    /* Update project
     */
    updateProject: function updateProject(event) {
      var activeProject = event.activeProject;

      var previousProject = event.previousProject;

      var dataLayer = config.layers[event.activeLayer].dataLayer;
      var activeProjectLatLang = event.activeProjectLatLang;

      // remove active styles from previous active project
      if (previousProject) {
        dataLayer.overrideStyle(previousProject, config.styles);
      }

      // add the active project style
      dataLayer.overrideStyle(activeProject, {
        fillColor: '#BE4459',
        fillOpacity: 1
      });

      // reposition map and set zeft
      map.panTo(activeProjectLatLang);
      map.setZoom(18);
    }
  };
};
'use strict';

var OVERLAY = function OVERLAY(shell) {
  return {
    init: function init() {
      shell.listen({
        'map-is-loaded': this.createOverlay
      });
    },
    destroy: function destroy() {},
    createOverlay: function createOverlay(map) {
      var bounds = new google.maps.LatLngBounds(new google.maps.LatLng(31.77278, 35.225652), new google.maps.LatLng(31.783742, 35.237573));

      var overlayImg = '../images/basemap.png';

      // Overlay constructor function
      function WELFAREOverlay(image) {
        // initialize all properties.
        this.bounds = bounds;
        this.image = image;
        this.map = map;

        // Define a property to hold the image's div. We'll
        // actually create this div upon recipt of the onAdd()
        // method so we'll leav it null for now.
        this.div = null;

        // Explicitly call setMap on this overlay.
        this.setMap(map);
      }

      WELFAREOverlay.prototype = new google.maps.OverlayView();

      /*
      onAdd is called when the map's panes are ready and the overlay has been
      added to the map
      */
      WELFAREOverlay.prototype.onAdd = function () {
        var div = document.createElement('div');
        div.style.borderStyle = 'none';
        div.style.borderWidth = '0px';
        div.style.position = 'absolute';

        // Create the img element and attach it to the div.
        var img = document.createElement('img');
        img.src = this.image;
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.position = 'absolute';
        div.appendChild(img);

        this.div = div;

        // Add the element to the 'overlayLayer' pane.
        var panes = this.getPanes();
        panes.overlayLayer.appendChild(div);
      };

      WELFAREOverlay.prototype.draw = function () {
        // We use the south-west and north-east coordinates
        // of the overlay to peg it to the correct position and size.
        // To do this, we need to retrieve the projection from the overlay.
        var overlayProjection = this.getProjection();

        // Retrieve the south-west and north-east coordinates of this overlay
        // in LatLngs and covert them to pixel coordinates.
        // We'll use these coordintes to resize the div.
        var sw = overlayProjection.fromLatLngToDivPixel(this.bounds.getSouthWest());
        var ne = overlayProjection.fromLatLngToDivPixel(this.bounds.getNorthEast());

        // Resize the image's div to fit the indicated dimensions
        var div = this.div;
        div.className = 'overlay';
        div.style.left = sw.x + 'px';
        div.style.top = ne.y + 'px';
        div.style.width = ne.x - sw.x + 'px';
        div.style.height = sw.y - ne.y + 'px';
      };

      // The onRemove() method will be called automatically from the API
      // If we ever set the overlay's map property to 'null'.
      WELFAREOverlay.prototype.onRemove = function () {
        this.div.parentNode.removeChild(this.div);
        this.div = null;
      };

      var overlay = new WELFAREOverlay(overlayImg);
    }
  };
};
'use strict';

var MESSAGES = function MESSAGES(shell) {
  var CONTAINER = shell.find('#messages');
  var msg = shell.find('.message');

  return {
    init: function init() {
      shell.listen({
        'app-updating': this.showLoader,
        'app-updated': this.hideLoader
      });
    },
    showLoader: function showLoader(event) {
      msg.innerHTML = event.message;
      CONTAINER.classList.add('js-active');
    },
    hideLoader: function hideLoader() {
      msg.innerHTML = '';
      CONTAINER.classList.remove('js-active');
    },
    destroy: function destroy() {}
  };
};
'use strict';

/* NAV MODULE */
var NAV = function NAV(shell) {
  var domMap = {};
  var navMap = {};
  var filteredData = {};
  var navState = {
    activeCategory: null,
    activeProject: null,
    previousProject: null,
    activeLayer: null
  };

  var debugmode = false;

  return {
    init: function init() {
      // Cache dom elements
      domMap.$nav = shell.find('#map__nav');
      domMap.$info = shell.find('.map-info');

      // Bind methods to this
      this.onNavClick = this.onNavClick.bind(this);
      this.setMainNav = this.setMainNav.bind(this);
      this.updateMainNav = this.updateMainNav.bind(this);
      this.updateProject = this.updateProject.bind(this);
      this.resetProject = this.resetProject.bind(this);
      this.onMapReset = this.onMapReset.bind(this);

      // Listen to global events
      shell.listen({
        'layers-created': this.setMainNav,
        'layers-data-updated': this.updateMainNav,
        'update-project': this.updateProject,
        'reset-project': this.resetProject,
        'reset-map': this.onMapReset
      });

      // Listen to click events on navigation
      domMap.$nav.addEventListener('click', this.onNavClick, false);
    },
    onMapReset: function onMapReset(data) {
      this.resetProject(data);
      this.resetNav(data);
    },


    // Should be called on layer update always regardless to state
    // state should be maintained by map
    updateMainNav: function updateMainNav(layers) {
      var data = layers.active && layers.active.data;
      var active = layers.active && layers.active.name;
      var previous = layers.previous && layers.previous.name;
      var populated = active && navMap[active].populated;

      navState.activeLayer = active;

      if (!active && previous) {
        shell.find('.map__nav__item-wrapper--' + previous).classList.remove('js-active');
        domMap.$nav.classList.remove('js-layerIsOpened');
        this.resetNav();
        return true;
      }
      // populate list with data if it's not already
      if (!populated && data) {
        this.setLayerNav(data, active);
        navMap[active].populated = true;
      }
      // handle classes
      if (previous) {
        shell.find('.map__nav__item-wrapper--' + previous).classList.remove('js-active');
        domMap.$nav.classList.remove('js-layerIsOpened', '' + active, '' + previous);
        this.resetNav();
      }
      if (active !== previous || active === previous && layers.active.visible) {
        shell.find('.map__nav__item-wrapper--' + active).classList.add('js-active');
        domMap.$nav.classList.add('js-layerIsOpened', '' + active);
      }
      return true;
    },
    resetNav: function resetNav() {
      if (navState.activeCategory) {
        this.closeCategory(navState.activeCategory, navState.activeCategory.nextElementSibling);
      }
    },
    setMainNav: function setMainNav(layers) {
      var _this = this;

      var tpl = Handlebars.templates['nav.tpl.hbs'](layers);
      shell.injectTemplateText(tpl, domMap.$nav);

      domMap.navItemWrapper = shell.findAll('.map__nav__item-wrapper');
      domMap.navItem = shell.findAll('.map__nav__item--layer');
      domMap.$about = shell.findAll('.about-btn');

      Object.keys(layers).forEach(function (key) {
        var obj = {};
        obj.populate = false;
        obj.parentEL = document.querySelector('.map__nav__item--' + key);
        obj.data = null;
        navMap[key] = obj;
      });

      domMap.$about.forEach(function (item) {
        item.addEventListener('click', _this.onAboutClick);
      });
    },
    buildProjectsLayerNavigation: function buildProjectsLayerNavigation(wrapper, data, activeLayer) {
      var buildCategoryHtml = function buildCategoryHtml(catName, catData) {
        var $catWrapper = shell.createElement('div', {
          class: ['map__nav__item--category', 'map__nav__item--category--' + catName]
        });
        var $catInner = shell.createElement('div', {
          class: ['category__inner']
        });
        var tpl = Handlebars.templates['nav-cat.tpl.hbs']({ title: catName });

        shell.injectTemplateText(tpl, $catWrapper);
        $catWrapper.appendChild($catInner);

        Object.keys(catData).forEach(function (key) {
          var id = catData[key].getProperty('RelatedEnglishTitle');
          if (catData[key].getGeometry().getAt(0)) {
            var itemTpl = Handlebars.templates['nav-layer-wcat.tpl.hbs']({ title: id, cat: catName });
            shell.injectTemplateText(itemTpl, $catInner);
          } else if (debugmode) {
            console.log(id + ' does not have geometry');
          }
        });
        return $catWrapper;
      };
      // Filter Duplicates
      if (!filteredData[activeLayer]) {
        var obj = {};
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var el = _step.value;

            // If the data set has categories, then filter/group them based on category name
            var category = el.getProperty('CatAName');
            var item = el.getProperty('RelatedEnglishTitle');
            if (!obj[category]) {
              obj[category] = {};
            }
            if (!obj[category][item]) {
              obj[category][item] = el;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        filteredData[activeLayer] = obj;
      }
      // Loop through data to add an element/link for each project in the layer navigation
      Object.keys(filteredData[activeLayer]).forEach(function (key) {
        var navGroup = buildCategoryHtml(key, filteredData[activeLayer][key]);
        wrapper.appendChild(navGroup);
      });
      shell.find('.map__nav__item-wrapper--' + activeLayer).appendChild(wrapper);
    },
    buildBuildingsLayerNavigation: function buildBuildingsLayerNavigation(wrapper, data, activeLayer) {
      var buildCategoryHtml = function buildCategoryHtml(catName, catData) {
        var $catWrapper = shell.createElement('div', {
          class: ['map__nav__item--category', 'map__nav__item--category--' + catName]
        });
        var $catInner = shell.createElement('div', {
          class: ['category__inner']
        });
        var tpl = Handlebars.templates['nav-cat-noicon.tpl.hbs']({ title: catName });

        shell.injectTemplateText(tpl, $catWrapper);
        $catWrapper.appendChild($catInner);

        Object.keys(catData).forEach(function (key) {
          var id = catData[key].alldata.BuildingName;
          if (catData[key].getGeometry() && catData[key].getGeometry().getAt(0)) {
            var itemTpl = Handlebars.templates['nav-layer-wcat.tpl.hbs']({ title: id, cat: catName });
            shell.injectTemplateText(itemTpl, $catInner);
          } else if (debugmode) {
            console.log(id + ' does not have geometry');
          }
        });
        return $catWrapper;
      };
      // Filter Duplicates
      if (!filteredData[activeLayer]) {
        (function () {
          var obj = {};
          var sortedData = [];
          var sortData = void 0;
          shell.get('data/sort.json').then(function (sdata) {
            sortData = sdata.Sort;
            sortData.forEach(function (el) {
              el.sort = parseInt(el.sort, 10);
            });

            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              var _loop = function _loop() {
                var el = _step2.value;

                // If the data set has categories, then filter/group them based on category name
                var category = el.alldata.BuildingType;
                var item = el.alldata.BuildingName.trim();
                if (!obj[category]) {
                  obj[category] = {};
                  obj[category].name = category;
                  obj[category].sort = sortData.find(function (element) {
                    return element.Name === category;
                  }).sort;
                }
                if (!obj[category].alldata) {
                  obj[category].alldata = {};
                }
                if (!obj[category].alldata[item]) {
                  obj[category].alldata[item] = el;
                }
              };

              for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                _loop();
              }

              // copy object to an array to get sorted
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }

            Object.keys(obj).forEach(function (key) {
              sortedData.push(obj[key]);
            });
            // sort data
            sortedData = _.sortBy(sortedData, 'sort');

            // update filtered data with sorted data
            filteredData[activeLayer] = sortedData;

            // Loop through data to add an element/link for each project in the layer navigation
            filteredData[activeLayer].forEach(function (cat) {
              var name = cat.name.replace(/ +/g, '');
              var navGroup = buildCategoryHtml(name, cat.alldata);
              wrapper.appendChild(navGroup);
            });
            shell.find('.map__nav__item-wrapper--' + activeLayer).appendChild(wrapper);
          });
        })();
      }
    },
    buildHousingLayerNavigation: function buildHousingLayerNavigation(wrapper, data, activeLayer) {
      var buildCategoryHtml = function buildCategoryHtml(catName, catData) {
        var $catWrapper = shell.createElement('div', {
          class: ['map__nav__item--category', 'map__nav__item--category--' + catName]
        });
        var $catInner = shell.createElement('div', {
          class: ['category__inner']
        });
        var tpl = Handlebars.templates['nav-cat-noicon.tpl.hbs']({ title: catData.buildingName });

        shell.injectTemplateText(tpl, $catWrapper);
        $catWrapper.appendChild($catInner);

        // loop through each building to add children studies to the navigation
        catData.alldata.forEach(function (el, index) {
          var title = 'Unit No.' + (index + 1);
          var itemTpl = Handlebars.templates['nav-layer-housing.tpl.hbs']({ target: index + 1, title: title, cat: catName });
          shell.injectTemplateText(itemTpl, $catInner);
        });
        return $catWrapper;
      };

      if (!filteredData[activeLayer]) {
        var obj = {};

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = data[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _el = _step3.value;

            // If the data set has categories, then filter/group them based on category name
            var _category = _el.buildingName.replace(/ +/g, '').replace(/\./g, '-');
            if (!obj[_category]) {
              obj[_category] = _el;
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        filteredData[activeLayer] = obj;
      }
      Object.keys(filteredData[activeLayer]).forEach(function (key) {
        var navGroup = buildCategoryHtml(key, filteredData[activeLayer][key]);
        wrapper.appendChild(navGroup);
      });
      shell.find('.map__nav__item-wrapper--' + activeLayer).appendChild(wrapper);
    },
    setLayerNav: function setLayerNav(data, activeLayer) {
      // Layer Inner Div
      var $navWrapper = shell.createElement('div', { class: ['map__nav__item__inner'] });

      switch (activeLayer) {
        case 'projects':
          this.buildProjectsLayerNavigation($navWrapper, data, activeLayer);
          break;
        case 'buildings':
          this.buildBuildingsLayerNavigation($navWrapper, data, activeLayer);
          break;
        case 'housing':
          this.buildHousingLayerNavigation($navWrapper, data, activeLayer);
          break;
        default:
          return true;
      }
    },
    resetProject: function resetProject(event) {
      if (!event.activeProject) {
        return true;
      }
      var projectName = void 0;
      switch (event.activeLayer) {
        case 'projects':
          projectName = event.activeProject.getProperty('RelatedEnglishTitle') || undefined;
          break;
        case 'buildings':
          projectName = event.activeProject.getProperty('BuildingNa') || undefined;
          break;
        case 'housing':
          break;
        default:
          break;
      }
      if (projectName) {
        shell.find('[data-target="' + projectName + '"]').classList.remove('js-active');
      }
      return true;
    },
    onProjectClick: function onProjectClick(el) {
      shell.notify({
        type: 'project-nav-clicked',
        data: {
          category: el.dataset.cat,
          target: el.dataset.target,
          data: filteredData
        }
      });
    },
    updateProject: function updateProject(event) {
      // NOTE: update project navigation classes here
      var activeLayer = event.activeLayer;
      var opts = {};
      var prevProj = void 0;
      var activeProj = void 0;
      var catEl = void 0;
      var catInner = void 0;

      if (activeLayer !== 'housing') {
        if (event.previousProjectName) {
          prevProj = shell.find('[data-target="' + event.previousProjectName + '"]');
          opts.prevProjCat = shell.find('.map__nav__item--category--' + prevProj.dataset.cat);
          opts.prevCatInner = opts.prevProjCat.querySelector('.category__inner');

          prevProj.classList.remove('js-active');
        }

        activeProj = shell.find('[data-target="' + event.activeProjectName + '"]');
        catEl = shell.find('.map__nav__item--category--' + activeProj.dataset.cat);
        catInner = catEl.querySelector('.category__inner');

        activeProj.classList.add('js-active');
        domMap.$nav.classList.add('js-layerIsOpened');
        opts.activeProj = activeProj;

        this.toggleCategory(catEl, catInner, true, opts);
      } else {
        if (event.previousProjectName) {
          var _cat = event.previousProject.buildingName.replace(/ +/g, '').replace(/\./g, '-');

          prevProj = shell.find('[data-target="' + event.previousProjectName + '"][data-cat="' + _cat + '"]');

          opts.prevProjCat = shell.find('.map__nav__item--category--' + _cat);
          opts.prevCatInner = opts.prevProjCat.querySelector('.category__inner');

          prevProj.classList.remove('js-active');
        }

        var cat = event.activeProject.buildingName.replace(/ +/g, '').replace(/\./g, '-');
        activeProj = shell.find('[data-target="' + event.activeProjectName + '"][data-cat="' + cat + '"]');

        catEl = shell.find('.map__nav__item--category--' + cat);
        catInner = catEl.querySelector('.category__inner');

        activeProj.classList.add('js-active');
        domMap.$nav.classList.add('js-layerIsOpened');
        opts.activeProj = activeProj;

        this.toggleCategory(catEl, catInner, true, opts);
      }
    },
    adjustProjectInnerPosition: function adjustProjectInnerPosition(el, left, width, content) {
      var element = el;
      var categoryInner = content;
      var trns = 0;
      var wdth = 0;
      var innerwidth = left + 3;

      if (navState.activeLayer === 'projects') {
        trns = (left + 3 - width) * -1;
        wdth = trns * -1 - 150;
      } else if (navState.activeLayer === 'buildings') {
        trns = (left + 3 - width) * -1;
        wdth = trns * -1 + 300;
        innerwidth = left + 3;
      } else {
        trns = (left + 3 - width) * -1;
        wdth = trns * -1 + 450;
        innerwidth = left + 3 + 450;
      }
      // If any of the categories expanded except for the first category
      // update the styles of the project navigation

      // reset map nav inner scroll position
      element.parentNode.scrollLeft = 0;

      // reposition map nav inner and adjust width
      var adjustPosition = function adjustPosition() {
        return new Promise(function (resolve, reject) {
          try {
            setTimeout(function () {
              element.parentNode.style.transform = 'translate3d(' + trns + 'px, 0, 0)';
              resolve();
            }, 200);
          } catch (error) {
            reject(error);
          }
        });
      };

      var adjustWidth = function adjustWidth() {
        return new Promise(function (resolve, reject) {
          try {
            setTimeout(function () {
              element.parentNode.style.width = 'calc(100% + ' + wdth + 'px)';
              resolve();
            }, 300);
          } catch (error) {
            reject(error);
          }
        });
      };

      adjustPosition().then(function () {
        adjustWidth().then(function () {
          categoryInner.style.width = 'calc(100% - ' + innerwidth + 'px)';
        }).catch(function (err) {
          console.log('adjusting width error: ' + err);
        });
      }).catch(function (err) {
        console.log('adjusting position error: ' + err);
      });
    },
    resetProjectInnerPosition: function resetProjectInnerPosition(el, content) {
      var element = el;
      var categoryInner = content;
      categoryInner.scrollLeft = 0;
      element.parentNode.removeAttribute('style');
      categoryInner.removeAttribute('style');
    },
    closeCategory: function closeCategory(el, content, fromMap) {
      var element = el || navState.activeCategory;
      if (!element) return;
      if (element && content) {
        this.resetProjectInnerPosition(element, content);
      }
      element.classList.remove('js-active');
      domMap.$nav.classList.remove('js-catIsOpened');
      if (!fromMap) {
        shell.notify({
          type: 'category-closed',
          data: { fromMap: fromMap }
        });
      }
    },
    openCategory: function openCategory(el, content) {
      var element = el || navState.activeCategory;

      // Reset navigation scroll first
      if (domMap.$nav.scrollLeft > 0) {
        domMap.$nav.scrollLeft = 0;
      }
      var elLeft = element.offsetLeft;
      var elWidth = element.offsetWidth;

      element.classList.add('js-active');
      domMap.$nav.classList.add('js-catIsOpened');

      this.adjustProjectInnerPosition(element, elLeft, elWidth, content);
    },
    toggleCategory: function toggleCategory(el, content, fromMap, opts) {
      var cnt = content;
      // If event is comming from map
      if (fromMap) {
        if (navState.activeCategory && el !== navState.activeCategory) {
          if (opts.prevProjCat) {
            this.closeCategory(opts.prevProjCat, opts.prevCatInner, fromMap);
          }
        }
        if (!el.classList.contains('js-active')) {
          this.openCategory(el, content);
        }
        navState.activeCategory = el;
        setTimeout(function () {
          cnt.scrollLeft = opts.activeProj.offsetLeft - opts.activeProj.offsetWidth;
        }, 10);
        return true;
      }

      // If event is coming from clicking on the category
      //
      // If last active category is the same as the clicked category
      // Then we are clicking the same category either show it or hide it depnding
      // on state and return
      if (navState.activeCategory && navState.activeCategory === el) {
        if (el.classList.contains('js-active')) {
          this.closeCategory(el, content);
        } else {
          this.openCategory(el, content);
        }
        return true;
      } else if (navState.activeCategory) {
        // Else if last active category exists and not
        // the same remove active from last active category
        navState.activeCategory.classList.remove('js-active');
        domMap.$nav.classList.remove('js-catIsOpened');
      }
      // Update last active categroy
      navState.activeCategory = el;
      this.openCategory(el, content);
      return true;
    },
    onNavClick: function onNavClick(event) {
      var el = void 0;
      var content = void 0;

      // alias classList
      var classes = event.target.classList;

      // Check event target
      if (event.currentTarget !== event.target) {
        // Click on `Project`.
        if (classes.contains('map__nav__item--project')) {
          el = event.target;
          this.onProjectClick(el);
        }

        // Click on `Category`.
        else if (classes.contains('category-wrapper')) {
            el = event.target.parentNode;
            content = event.target.nextElementSibling;
            this.toggleCategory(el, content);
          }

          // Click on either `Layer` or `Category` link.
          else if (classes.contains('map__nav__item__icon') || classes.contains('map__nav__item__name')) {
              el = event.target.parentNode.parentNode;
              // We are only interested on click events on `Category` links.
              if (el.classList.contains('map__nav__item--category')) {
                content = event.target.parentNode.nextElementSibling;
                this.toggleCategory(el, content);
              }
            }

            // If it reaches here, click happened on `Project`.
            else if (classes.contains('map__nav__item__title')) {
                el = event.target.parentNode;
                this.onProjectClick(el);
              }
      }
      event.stopPropagation();
      return true;
    },
    onAboutClick: function onAboutClick(event) {
      shell.notify({
        type: 'about-clicked',
        data: event.target.dataset.target
      });
    }
  };
};
//